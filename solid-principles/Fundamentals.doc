SOLID Principles:
-	S = Single Responsibility Principle:  A class should have one, and only one, reason to change. This means that a class must have only one responsibility.

-	O = Open/Closed Principle: Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
This means the design of a software entity should be such that you can introduce new functionality or behaviour without modifying the existing code since changing the existing code might introduce bugs.

By introducing an abstraction (Shape class) and separating the concrete implementations (Rectangle and Circle classes), we can add new shapes without modifying the existing code.
The ShapeCalculator class can now work with any shape that implements the Shape interface, allowing for easy extensibility.

-	L = Liskov Substitution Principle (LSP): Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.
This means if you have a base class and a derived class, you should be able to use instances of the derived class wherever instances of the base class are expected, without breaking the application.

-	I = Interface Segregation Principle (ISP): No client should be forced to depend on interfaces they don't use.
The main idea behind ISP is to prevent the creation of "fat" or "bloated" interfaces that include methods that are not required by all clients.
By segregating interfaces into smaller, more specific ones, clients only depend on the methods they actually need, promoting loose coupling and better code organization.

-	D = Dependency Inversion Principle (DIP):  High-level modules should not depend on low-level modules; both should depend on abstractions.
This means that a particular class should not depend directly on another class, but on an abstraction (interface) of this class.
Applying this principle reduces dependency on specific implementations and makes our code more reusable.






